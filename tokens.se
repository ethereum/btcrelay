
extern btcrelayTokenFactory: [createStandardToken:[uint256]:address]

extern btcrelayToken: [sendCoin:[uint256,address]:bool, sendCoinFrom:[address,uint256,address]:bool, coinBalance:[]:address, coinBalanceOf:[address]:address]


# TODO pack more data in the slot of tokenContract?
# address of contract that will issue btcrelay tokens
data tokenContract

# TODO optimize by avoiding this extra storage slot?
data numTokenIssued


# TODO move to constants.se
#macro TOKEN_FACTORY: 0xfd5aee44be7195a704a86c18dfc0b65813486f7e
macro TOKEN_ENDOWMENT: 2**200
macro REWARD_PER_HEADER: 1000
macro FEE_VERIFY_TX: 100000000000000000  # 0.1 ETH


event rewardToken(blockHeight:indexed, rewardAddr:address)  # TODO: indexed or not?
event ethPayment()



def initTokenContract(tokenFactoryAddr):
    if !self.tokenContract:  # can only be set once
        self.tokenContract = tokenFactoryAddr.createStandardToken(TOKEN_ENDOWMENT)
        return(self.tokenContract)

def getTokenContract():
    return(self.tokenContract)



# tx.origin is issued tokens when a blockHeader is stored
macro rewardForBlockHeader($blockHeight):
    # reward tx.origin, since storeBlockHeader() may be called indirectly like bulkStoreHeader()
    if self.tokenContract.sendCoin(REWARD_PER_HEADER, tx.origin):
        self.numTokenIssued += REWARD_PER_HEADER
        log(type=rewardToken, $blockHeight, tx.origin)  # TODO: should msg.sender also be logged


macro chargeVerifyTx():
    msg.value >= FEE_VERIFY_TX


# TODO tx.origin ?
macro m_cashOut($numToken):
    if self.tokenContract.sendCoinFrom(msg.sender, $numToken, self):
        $numEth = self.balance * $numToken / self.numTokenIssued
        self.numTokenIssued -= $numToken
        send(msg.sender, $numEth)
